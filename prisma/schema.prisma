generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                        String                     @id @default(cuid())
  email                     String                     @unique
  name                      String?
  password                  String
  leagueAccountId           String?
  riotPuuid                 String?
  riotRegion                String?
  role                      String                     @default("user")
  subscriptionTier          String                     @default("free")
  subscriptionExpiresAt     DateTime?
  dailyAnalysesUsed         Int                        @default(0)
  dailyAnalysisLimit        Int                        @default(3)
  lastDailyReset            DateTime                   @default(now())
  lastLoginAt               DateTime?
  createdAt                 DateTime                   @default(now())
  updatedAt                 DateTime                   @updatedAt
  leagueAccount             LeagueOfLegendsAccount?    @relation(fields: [leagueAccountId], references: [id])
  championAdvices           ChampionAdvice[]
  championAdviceVotes       ChampionAdviceVote[]
  compositions              Composition[]
  championGuides            ChampionGuide[]
  championGuideVotes        ChampionGuideVote[]
  championGuideComments     ChampionGuideComment[]
  championGuideCommentVotes ChampionGuideCommentVote[]

  @@unique([riotPuuid, riotRegion])
  @@index([riotPuuid, riotRegion])
  @@map("users")
}

model Champion {
  id                   String   @id @default(cuid())
  championId           String   @unique
  name                 String   @unique
  title                String
  blurb                String?
  attack               Int
  defense              Int
  magic                Int
  difficulty           Int
  hp                   Float
  hpPerLevel           Float
  mp                   Float?
  mpPerLevel           Float?
  moveSpeed            Int
  armor                Float
  armorPerLevel        Float
  spellBlock           Float
  spellBlockPerLevel   Float
  attackRange          Float
  hpRegen              Float
  hpRegenPerLevel      Float
  mpRegen              Float?
  mpRegenPerLevel      Float?
  crit                 Float
  critPerLevel         Float
  attackDamage         Float
  attackDamagePerLevel Float
  attackSpeed          Float
  attackSpeedPerLevel  Float
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  championKey          Int?     @unique

  @@map("champions")
}

model Item {
  id          String   @id @default(cuid())
  itemId      String   @unique
  name        String
  description String?
  plaintext   String?
  image       String?
  gold        String?
  tags        String?  // JSON array of tags (Boots, Jungle, etc.)
  depth       Int?     // Item depth (1=component, 2=tier2, 3=completed)
  fromItems   String?  // JSON array of item IDs this builds from
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("items")
}

model Match {
  id           String             @id @default(cuid())
  matchId      String             @unique
  gameCreation BigInt
  gameDuration Int
  gameMode     String
  gameType     String
  gameVersion  String
  mapId        Int
  platformId   String
  queueId      Int
  region       String
  blueTeamWon  Boolean?
  redTeamWon   Boolean?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt
  participants MatchParticipant[]

  @@index([platformId])
  @@index([queueId])
  @@index([gameCreation])
  @@index([region])
  @@index([region, queueId])
  @@map("matches")
}

model MatchParticipant {
  id                          String   @id @default(cuid())
  matchId                     String
  participantId               Int
  teamId                      Int
  championId                  String
  role                        String?
  lane                        String?
  kills                       Int      @default(0)
  deaths                      Int      @default(0)
  assists                     Int      @default(0)
  goldEarned                  Int      @default(0)
  goldSpent                   Int      @default(0)
  totalDamageDealtToChampions Int      @default(0)
  totalDamageTaken            Int      @default(0)
  visionScore                 Int      @default(0)
  win                         Boolean  @default(false)
  item0                       Int?
  item1                       Int?
  item2                       Int?
  item3                       Int?
  item4                       Int?
  item5                       Int?
  item6                       Int?
  summoner1Id                 Int?
  summoner2Id                 Int?
  riotIdGameName              String?
  riotIdTagline               String?
  createdAt                   DateTime @default(now())
  updatedAt                   DateTime @updatedAt
  participantPUuid            String?
  match                       Match    @relation(fields: [matchId], references: [id], onDelete: Cascade)

  @@unique([matchId, participantId])
  @@index([championId])
  @@index([teamId])
  @@index([matchId])
  @@index([participantPUuid])
  @@map("match_participants")
}

model CompositionSuggestion {
  id                String   @id @default(cuid())
  userId            String?
  teamChampions     String
  enemyChampions    String?
  role              String
  suggestedChampion String
  confidence        Float    @default(0)
  reasoning         String?
  gameMode          String?
  tier              String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  playstyle         String?
  strengths         String?
  weaknesses        String?

  // Enhanced composition data
  counters        String? // JSON: [{championId, winRateAgainst}]
  roleSynergies   String? // JSON: {top: [...], jungle: [...], ...}
  avgDamagePerMin Float?
  avgGoldPerMin   Float?
  avgVisionPerMin Float?
  aiReasoning     String? @db.Text // AI-generated reasoning

  @@index([role])
  @@index([userId])
  @@index([confidence])
  @@index([suggestedChampion])
  @@map("composition_suggestions")
}

model Composition {
  id        String   @id @default(cuid())
  userId    String
  name      String
  top       String?
  jungle    String?
  mid       String?
  adc       String?
  support   String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([createdAt])
  @@map("compositions")
}

model DiscoveredPlayer {
  id               String    @id @default(cuid())
  puuid            String    @unique
  riotGameName     String?
  riotTagLine      String?
  riotRegion       String
  lastCrawledAt    DateTime?
  crawlStatus      String    @default("pending")
  matchesCollected Int       @default(0)
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([crawlStatus])
  @@index([puuid])
  @@index([riotRegion])
  @@map("discovered_players")
}

model LeagueOfLegendsAccount {
  id                 String                    @id @default(cuid())
  puuid              String                    @unique
  riotGameName       String?
  riotTagLine        String?
  riotRegion         String
  riotSummonerId     String?
  riotAccountId      String?
  summonerLevel      Int?
  profileIconId      Int?
  revisionDate       BigInt?
  totalMatches       Int                       @default(0)
  totalWins          Int                       @default(0)
  totalLosses        Int                       @default(0)
  winRate            Float                     @default(0)
  avgKDA             Float                     @default(0)
  mostPlayedChampion String?
  createdAt          DateTime                  @default(now())
  updatedAt          DateTime                  @updatedAt
  playerChallenges   PlayerChallenge[]
  User               User[]
  overviewHistory    SummonerOverviewHistory[]

  @@index([puuid])
  @@index([riotRegion])
  @@index([riotGameName])
  @@map("league_accounts")
}

model LeaderboardEntry {
  id           String   @id @default(cuid())
  region       String
  queueType    String   @default("RANKED_SOLO_5x5")
  tier         String
  rank         String?
  summonerId   String
  summonerName String
  leaguePoints Int
  wins         Int
  losses       Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([region, queueType, tier, summonerId])
  @@index([region, tier])
  @@index([leaguePoints])
  @@index([region, queueType, leaguePoints])
  @@map("leaderboard_entries")
}

model ChampionStats {
  id             String   @id @default(cuid())
  championId     String   @unique
  totalGames     Int      @default(0)
  totalWins      Int      @default(0)
  totalLosses    Int      @default(0)
  winRate        Float    @default(0)
  avgKills       Float    @default(0)
  avgDeaths      Float    @default(0)
  avgAssists     Float    @default(0)
  avgKDA         Float    @default(0)
  avgGoldEarned  Float    @default(0)
  avgGoldSpent   Float    @default(0)
  avgDamageDealt Float    @default(0)
  avgDamageTaken Float    @default(0)
  avgVisionScore Float    @default(0)
  topRole        String?
  topLane        String?
  weakAgainst    Json?
  lastAnalyzedAt DateTime @default(now())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  score          Float    @default(0)

  @@index([championId])
  @@index([winRate])
  @@index([totalGames])
  @@index([score])
  @@map("champion_stats")
}

model SummonerOverviewHistory {
  id         String   @id @default(cuid())
  summonerId String
  totalGames Int
  totalWins  Int
  winRate    Float
  recordedAt DateTime @default(now())

  summoner LeagueOfLegendsAccount @relation(fields: [summonerId], references: [id], onDelete: Cascade)

  @@index([summonerId, recordedAt])
  @@map("summoner_overview_history")
}

model ChampionAdvice {
  id         String               @id @default(cuid())
  championId String
  authorId   String?
  authorName String?
  content    String
  score      Int                  @default(0)
  upvotes    Int                  @default(0)
  downvotes  Int                  @default(0)
  createdAt  DateTime             @default(now())
  updatedAt  DateTime             @updatedAt
  author     User?                @relation(fields: [authorId], references: [id], onDelete: SetNull)
  votes      ChampionAdviceVote[]

  @@index([championId])
  @@index([score])
  @@index([score, createdAt])
  @@map("champion_advices")
}

model ChampionAdviceVote {
  id        String         @id @default(cuid())
  adviceId  String
  userId    String
  value     Int
  advice    ChampionAdvice @relation(fields: [adviceId], references: [id], onDelete: Cascade)
  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt

  @@unique([adviceId, userId])
  @@index([userId])
  @@map("champion_advice_votes")
}

model Challenge {
  challengeId      Int               @id
  name             String
  shortDescription String?
  description      String?
  category         String?
  level            String?
  thresholds       Json?
  tags             String?
  maxValue         Float?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  playerProgress   PlayerChallenge[]

  @@map("challenges")
}

model PlayerChallenge {
  id                String                 @id @default(cuid())
  leagueAccountId   String
  challengeId       Int
  currentValue      Float                  @default(0)
  currentLevel      String                 @default("NONE")
  highestLevel      String?
  percentile        Float?
  achievedTime      DateTime?
  nextLevelValue    Float?
  progress          Float?
  pointsEarned      Float?
  completedLevels   String?
  lastUpdatedByRiot DateTime?
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  challenge         Challenge              @relation(fields: [challengeId], references: [challengeId], onDelete: Cascade)
  leagueAccount     LeagueOfLegendsAccount @relation(fields: [leagueAccountId], references: [id], onDelete: Cascade)

  @@unique([leagueAccountId, challengeId])
  @@map("player_challenges")
}

model GameVersion {
  id        String   @id @default(cuid())
  version   String   @unique
  isCurrent Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("game_versions")
}

model ChampionWinRateHistory {
  id          String   @id @default(cuid())
  championId  String
  winRate     Float
  totalGames  Int
  totalWins   Int
  totalLosses Int
  recordedAt  DateTime @default(now())

  @@index([championId])
  @@index([championId, recordedAt])
  @@index([recordedAt])
  @@map("champion_win_rate_history")
}

model FavoritePlayer {
  id        String   @id @default(cuid())
  userId    String
  puuid     String
  region    String
  gameName  String?
  tagLine   String?
  note      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, puuid])
  @@index([userId])
  @@index([puuid])
  @@map("favorite_players")
}

model RankHistory {
  id           String   @id @default(cuid())
  puuid        String
  region       String
  queueType    String   @default("RANKED_SOLO_5x5")
  tier         String
  rank         String
  leaguePoints Int
  wins         Int
  losses       Int
  recordedAt   DateTime @default(now())

  @@index([puuid, queueType])
  @@index([puuid, recordedAt])
  @@map("rank_history")
}

// ============================================
// Champion Guides System
// ============================================

model ChampionGuide {
  id             String   @id @default(cuid())
  championId     String
  authorId       String?
  authorName     String?
  title          String
  introduction   String?  @db.Text

  // Build configuration (stored as JSON)
  itemBuild      Json? // {starter: [], core: [], situational: [], boots: []}
  skillOrder     Json? // {levels: {1: "Q", 2: "W", ...}, maxOrder: ["Q","W","E"]}
  runeConfig     Json? // {primary: {tree, keystone, slots}, secondary: {tree, slots}, shards: []}
  summonerSpells Json? // [spellId1, spellId2]

  // Gameplay sections
  earlyGameTips  String?  @db.Text
  midGameTips    String?  @db.Text
  lateGameTips   String?  @db.Text

  // Matchup data
  goodMatchups   Json? // [{championId, difficulty, notes}]
  badMatchups    Json? // [{championId, difficulty, notes}]

  // Strengths/Weaknesses
  strengths      Json? // string[]
  weaknesses     Json? // string[]

  // Metadata
  patchVersion   String?
  role           String? // TOP, JUNGLE, MID, ADC, SUPPORT

  // Voting (denormalized counters)
  score          Int      @default(0)
  upvotes        Int      @default(0)
  downvotes      Int      @default(0)
  viewCount      Int      @default(0)

  // Status
  status         String   @default("published") // draft, published

  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  author         User?               @relation(fields: [authorId], references: [id], onDelete: SetNull)
  votes          ChampionGuideVote[]
  comments       ChampionGuideComment[]

  @@index([championId])
  @@index([authorId])
  @@index([score, createdAt])
  @@index([championId, role])
  @@index([status, championId])
  @@index([viewCount, createdAt])
  @@map("champion_guides")
}

model ChampionGuideVote {
  id        String        @id @default(cuid())
  guideId   String
  userId    String
  value     Int // -1, 0, 1
  guide     ChampionGuide @relation(fields: [guideId], references: [id], onDelete: Cascade)
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  @@unique([guideId, userId])
  @@index([userId])
  @@map("champion_guide_votes")
}

model ChampionGuideComment {
  id         String   @id @default(cuid())
  guideId    String
  authorId   String?
  authorName String?
  content    String   @db.Text

  // Voting on comments
  score      Int      @default(0)
  upvotes    Int      @default(0)
  downvotes  Int      @default(0)

  // Parent for nested replies
  parentId   String?

  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  guide      ChampionGuide              @relation(fields: [guideId], references: [id], onDelete: Cascade)
  author     User?                      @relation(fields: [authorId], references: [id], onDelete: SetNull)
  parent     ChampionGuideComment?      @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies    ChampionGuideComment[]     @relation("CommentReplies")
  votes      ChampionGuideCommentVote[]

  @@index([guideId])
  @@index([authorId])
  @@index([parentId])
  @@index([score])
  @@map("champion_guide_comments")
}

model ChampionGuideCommentVote {
  id        String               @id @default(cuid())
  commentId String
  userId    String
  value     Int
  comment   ChampionGuideComment @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user      User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  createdAt DateTime             @default(now())
  updatedAt DateTime             @updatedAt

  @@unique([commentId, userId])
  @@map("champion_guide_comment_votes")
}
